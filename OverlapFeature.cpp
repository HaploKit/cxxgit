
/*
 * This program is used to calculate the features of long/short reads overlaps,
 * such as overlap score, gap numbers, gap length, etc. The overlap file(PAF format)
 * generated by aligner (Minimap2) and FASTQ file are required as input.
 *
 * Output options(a,b):
 *
 * a.(with -r)
 *  the first 12 columns in PAF / overlap length / base identity / overlap score / overhang ratio /
 *  gap numbers / gap total length
 *
 * b.(without -r)
 * query name / target name / overlap length / base identity / overlap score / expectation
 *
 *
 * Note:
 *
 * The C++ library Boost must be preinstalled.
 *
 * Compile with command line: (GCC version>=4.9)
 * source activate gcc49 # on walter
 * g++ -std=c++11 -o ovlpf OverlapFeature.cpp -lz -lboost_iostreams -lboost_program_options -pthread
 * On Macbook:
 * /usr/bin/g++ -std=c++11 -o ovlpf OverlapFeature.cpp -lz -lboost_iostreams -lboost_program_options -pthread
 *
 * Created by Vincent on 2019-03-09.
*/

#include <iostream>
#include <fstream>
#include <string>
#include <regex>
#include <vector>
#include <unordered_map>
#include <thread>
#include <mutex>
#include <boost/program_options.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/iostreams/filtering_streambuf.hpp>
#include <boost/iostreams/copy.hpp>
#include <boost/iostreams/filter/gzip.hpp>
#include <boost/bind.hpp>

//
typedef std::unordered_map<std::string, std::vector<std::string>> HASH_SEQ;

//
std::mutex mt;

// Program Settings
struct ProgramSettings {
    std::string fastq_file;
    std::string overlaps_file;
    std::string output_file;
    bool redundant = true;
    unsigned int n_threads = 1;

};


// declare functions
HASH_SEQ read_fastq(std::string filename);

double phred_to_prob(int phred);

std::string revcomp(std::string s);

std::vector<double> score(char nt1, char nt2, double p1, double p2);

std::vector<double> analyze_overlap(std::string seq1, std::string seq2, std::string phred1, std::string phred2,
                                    unsigned start1, unsigned start2, unsigned end1, unsigned end2, char strand,
                                    unsigned match_len, std::string cigar);

std::vector<double> get_overlap_score(std::string seq1, std::string seq2, std::string score1, std::string score2);

void write_ovlpf(std::string line, HASH_SEQ &r2seq_phred, std::ofstream &outpaf, bool mode);


int main(int argc, char *argv[]) {
    namespace po = boost::program_options;

    ProgramSettings program_settings;
    po::options_description desc("This program is used to calculate the features of "
                                 "long/short reads overlap\n"
                                 "Version: 1.0\nContact: vincent@cwi.nl\nOptions");

    desc.add_options()
            ("help,h", "produce help message")
            ("fastq,i", po::value<std::string>(&program_settings.fastq_file), "path to fastq(.gz) files(fq1,fq2...)")
            ("overlaps,p", po::value<std::string>(&program_settings.overlaps_file), "path to overlap file")
            ("outfile,o", po::value<std::string>(&program_settings.output_file)->default_value("out.paf"),
             "path to output file")
            ("threads,t", po::value<unsigned int>(&program_settings.n_threads)->default_value(1),
             "set the number of threads")
            ("redundant,r", po::value<bool>(&program_settings.redundant)->default_value(true),
             "if output more columns for long reads, default: true");
    po::variables_map vm;
    po::store(po::parse_command_line(argc, argv, desc), vm);

    if (vm.count("help")) {
        std::cout << desc << "\n";
        return 0;
    }

    po::notify(vm);

    if (!(vm.count("fastq"))) {
        std::cerr << "No fastq file provided.\n\n";
        std::cout << desc << "\n";
        return 1;
    }

    if (!vm.count("overlaps")) {
        std::cerr << "No overlaps file provided.\n\n";
        std::cout << desc << "\n";
        return 1;
    }
    // create log file
//    std::ofstream logfile;
//    logfile.open("log.txt", std::fstream::out);
//    logfile << "Program Starts...\n";
//    logfile << "Reading Fastq File...\n";
    std::cout << "Program Starts...\n\n";
    std::cout << "Reading Fastq File...\n";

    // read fastq file to hash: read id -> [seq, phred]
    HASH_SEQ r2seq_phred = read_fastq(program_settings.fastq_file);


    // read overlap file by line and compute features
    std::cout << "Reading Finished...\n";
    std::cout << "Processing Overlap file...\n\n";

//    program_settings.overlaps_file = "/Users/xiaoluo/Documents/CWI/project/TGS_assembly/OverlapFeature/long_read_analysis/test/overlaps.paf";
//    program_settings.overlaps_file = "/Users/xiaoluo/Documents/CWI/project/TGS_assembly/OverlapFeature/long_read_analysis/test/test4shortreads/short_reads.paf";

    std::ifstream fo(program_settings.overlaps_file);
    if (!fo) {
        std::cerr << "Error when reading " + program_settings.overlaps_file + "\n";
        exit(1);
    }

    // output the overlap PAF file. It can be either succinct or redundant.
    std::ofstream outpaf(program_settings.output_file);
    if (!outpaf) {
        std::cerr << "Error when writing to " + program_settings.output_file + "\n";
    }

//    output by line
    bool mode = program_settings.redundant;
    unsigned t = program_settings.n_threads;

    std::thread tr[t]; // create thread pool
    std::string line;
    while (fo.peek() != EOF) {
        for (int i = 0; i < t; i++) {
            getline(fo, line);

            tr[i] = std::thread(boost::bind(write_ovlpf, line, boost::ref(r2seq_phred), boost::ref(outpaf), mode));

        }
        for (int i = 0; i < t; i++) {
            tr[i].join(); //wait for the end of processing threads
        }

    }

    std::cout << "Program finished...\n\n";

    fo.close();
    outpaf.close();
//    logfile.close();

    return 0;
}


// define sub functions

std::unordered_map<std::string, std::vector<std::string> > read_fastq(std::string filenames) {

    std::unordered_map<std::string, std::vector<std::string> > r2seq_phred;
    std::vector<std::string> seq_phred;

//    filename = "/Users/xiaoluo/Documents/CWI/project/TGS_assembly/OverlapFeature/long_read_analysis/test/fastq_merged_100Reads.fastq";
//    filename = "/Users/xiaoluo/Documents/CWI/project/meta_assembly/OGRE_test/fastq/test.fq";
    std::vector<std::string> fq_list;
    boost::split(fq_list, filenames, boost::is_any_of(","), boost::token_compress_on);
    std::string filename;

    for (int i = 0; i < fq_list.size(); i++) {
        filename = fq_list[i];

        if (boost::algorithm::ends_with(filename, ".gz")) {
            std::ifstream file(filename, std::ios_base::in | std::ios_base::binary);
            boost::iostreams::filtering_streambuf<boost::iostreams::input> inbuf;
            inbuf.push(boost::iostreams::gzip_decompressor());
            inbuf.push(file);
            //Convert streambuf to istream
            std::istream instream(&inbuf);

            if (!file) {
                std::cerr << "Error when reading " + filename + "\n";
                exit(1);
            }

            std::string line;
            std::string read;
            std::string seq;
            std::string phred;
            std::vector<std::string> svec;
            int c = 0;
            while (std::getline(instream, line)) {
                switch (c % 4) {
                    case 0: {
                        if (!boost::algorithm::starts_with(line, "@")) {
                            std::cerr << "Error: Reads ID should begin with @. Exiting...\n";
                            exit(1);
                        }
                        if (!read.empty() && !seq.empty() && !phred.empty()) {
                            seq_phred = {seq, phred};
                            r2seq_phred[read] = seq_phred;
                        }
                        read = line.substr(1);
                        boost::split(svec, read, boost::is_space());
                        read = svec[0];
                        c++;
                        break;
                    }
                    case 1: {
                        seq = line;
                        c++;
                        break;
                    }
                    case 2: {
                        c++;
                        break;
                    }
                    case 3: {
                        phred = line;
                        c++;
                        break;
                    }
                    default:
                        break;
                }
            }
            // write the final entry
            if (!read.empty() && !seq.empty() && !phred.empty()) {
                seq_phred[0] = seq;
                seq_phred[1] = phred;
                r2seq_phred[read] = seq_phred;

            }

            file.close();
            svec.clear();
        } else {
            std::ifstream fr(filename);
            if (!fr) {
                std::cerr << "Error when reading " + filename + "\n";
                exit(1);
            }
            std::string line;
            std::string read;
            std::string seq;
            std::string phred;
            std::vector<std::string> svec;
            int c = 0;
            while (getline(fr, line)) {
                switch (c % 4) {
                    case 0: {
                        if (!boost::algorithm::starts_with(line, "@")) {
                            std::cerr << "Error: Reads ID should begin with @. Exiting...\n";
                            exit(1);
                        }
                        if (!read.empty() && !seq.empty() && !phred.empty()) {
                            seq_phred = {seq, phred};
                            r2seq_phred[read] = seq_phred;
                        }
                        read = line.substr(1);
                        boost::split(svec, read, boost::is_space());
                        read = svec[0];
                        c++;
                        break;
                    }
                    case 1: {
                        seq = line;
                        c++;
                        break;
                    }
                    case 2: {
                        c++;
                        break;
                    }
                    case 3: {
                        phred = line;
                        c++;
                        break;
                    }
                    default:
                        break;
                }
            }
            // write the final entry
            if (!read.empty() && !seq.empty() && !phred.empty()) {
                seq_phred[0] = seq;
                seq_phred[1] = phred;
                r2seq_phred[read] = seq_phred;

            }

            fr.close();
            svec.clear();
        }
    }
    return r2seq_phred;
}


double phred_to_prob(const int phred) {
    double P = pow(10, -phred / 10.0);
    assert (P >= 0 && P <= 1);
    return P;
}

// computes score for 2 specific nucleotides and their qualities
std::vector<double> score(char nt1, char nt2, double p1, double p2) {
//    assert (nt1 == 'A' || nt1 == 'T' || nt1 == 'C' || nt1 == 'G' || nt1 == 'N');
//    assert (nt2 == 'A' || nt2 == 'T' || nt2 == 'C' || nt2 == 'G' || nt2 == 'N');
    double p;
    if ((nt1 != 'A' && nt1 != 'T' && nt1 != 'C' && nt1 != 'G') ||
        (nt2 != 'A' && nt2 != 'T' && nt2 != 'C' && nt2 != 'G')) { // degenerate base symbols are not considered yet
//        p = 0.25;
        return {1, 1};
    } else if (nt1 == nt2) {
        p = (1 - p1) * (1 - p2) + (p1 * p2) / 3.0;
    } else {
        p = p1 * (1 - p2) / 3.0 + p2 * (1 - p1) / 3.0 + (2 / 9.0) * p1 * p2;
    }
    assert (p > 0 && p <= 1);
    double lp = log(p);
    assert (lp == lp); // checks that lp != NaN
    assert (lp <= 0);
    double expect = p; // if it really makes sense

    return {lp, expect};
}


// Overlap score computation for 2 given sequences and phred scores
std::vector<double> get_overlap_score(std::string seq1, std::string seq2, std::string score1, std::string score2) {
    assert (seq1.length() > 0);
    assert (seq2.length() > 0);
    assert (score1.length() > 0);
    assert (score2.length() > 0);
    assert (seq1.length() == seq2.length());
    assert (score1.length() == score2.length());

    int L = static_cast<int>(seq1.length()); // overlap length

    std::vector<double> probs1;
    std::vector<double> probs2;
    for (int i = 0; i < L; i++) {
        int Q1 = static_cast<int>(score1.at(i)) - 33;
        int Q2 = static_cast<int>(score2.at(i)) - 33;
        double P1 = phred_to_prob(Q1);
        double P2 = phred_to_prob(Q2);
        assert (P1 == P1 && P1 >= 0 && P1 <= 1);
        assert (P2 == P2 && P2 >= 0 && P2 <= 1);
        probs1.push_back(P1);
        probs2.push_back(P2);
    }

    double total_score = 0.0;
    double total_expect = 0.0;
    std::vector<double> score_vec;

//    double total_len = 0.0; // count the number of overlapping A/C/T/G nucleotides
    for (unsigned long i = 0; i < L; i++) {
        score_vec = score(seq1.at(i), seq2.at(i), probs1.at(i), probs2.at(i));
        if (score_vec[0] == 1) {
            continue; // skip degenerate base symbols
        }
        total_score += score_vec[0];
        total_expect += score_vec[1];
//        total_len += 1;
    }
//    total_score = (1.0 / total_len) * total_score; # only for contiguous sequence

    return {total_score, total_expect};
}

std::string revcomp(std::string s) {
    //get reversed complementary sequence
    std::string temp_str;
    std::reverse(s.begin(), s.end());

    for (unsigned long i = 0; i < s.length(); i++) {
        if (s.substr(i, 1) == "A" || s.substr(i, 1) == "a") {
            temp_str += "T";
        } else if (s.substr(i, 1) == "T" || s.substr(i, 1) == "t") {
            temp_str += "A";
        } else if (s.substr(i, 1) == "C" || s.substr(i, 1) == "c") {
            temp_str += "G";
        } else if (s.substr(i, 1) == "G" || s.substr(i, 1) == "g") {
            temp_str += "C";
        } else {
            temp_str += "N";
        }
    }
    s = temp_str;
    return s;
}

std::vector<double> analyze_overlap(std::string seq1, std::string seq2, std::string phred1, std::string phred2,
                                    unsigned start1, unsigned start2, unsigned end1, unsigned end2, char strand,
                                    unsigned match_len, std::string cigar) {
    double ovlp_score = 0.0;
    double expect = 0.0;
    double ngaps;
    double gaplen;

    std::smatch sub_cigar;
//    std::regex pattern("(\\d+)([MDISH])");
    std::regex pattern("(\\d+)([MDI])");

    std::string::const_iterator it_start = cigar.begin();
    std::string::const_iterator it_end = cigar.end();
    std::string type;
    unsigned length;
    unsigned n_ins = 0;
    unsigned n_del = 0;
    unsigned len_ins = 0;
    unsigned len_del = 0;
    unsigned pos1 = start1;
    unsigned pos2 = start2;
//    unsigned match_len = 0;
    std::string subseq1;
    std::string subseq2;
    std::string subphred1;
    std::string subphred2;
    std::vector<double> ovlp_vec;

    if (strand == '-') {
        std::reverse(phred2.begin(), phred2.end());
        seq2 = revcomp(seq2);
        pos2 = seq2.length() - end2; // PAF uses 0-based coordinate: [start,end)

    }

    while (regex_search(it_start, it_end, sub_cigar, pattern)) {
        length = std::stoi(sub_cigar[1]);
        type = sub_cigar[2];
//        std::cout << type << "\t" << length << "\n";

        if (type == "I") {
            n_ins++;
            len_ins += length;
            pos1 += length;
        } else if (type == "D") {
            n_del++;
            len_del += length;
            pos2 += length;
        } else if (type == "M") {

            subseq1 = seq1.substr(pos1, length);
            subseq2 = seq2.substr(pos2, length);

            assert (subseq1.length() > 0);
            assert (subseq2.length() > 0);
            assert (subseq1.length() == subseq2.length());

            subphred1 = phred1.substr(pos1, length);
            subphred2 = phred2.substr(pos2, length);

            assert(subphred1.length() > 0);
            assert(subphred2.length() > 0);
            assert(subphred1.length() == subphred2.length());

            ovlp_vec = get_overlap_score(subseq1, subseq2, subphred1, subphred2);

            ovlp_score += ovlp_vec[0];
            expect += ovlp_vec[1];
            pos1 += length;
            pos2 += length;
//            match_len += length;
        } else {
            std::cerr << "Error: CIGAR strings only support IDM characters. Exiting...\n";
            exit(1);
        }
        it_start = sub_cigar[0].second;
    }
    ovlp_score = exp(ovlp_score / match_len);
    assert(ovlp_score >= 0 && ovlp_score <= 1);

    ngaps = n_ins + n_del;
    gaplen = len_ins + len_del;
    return {ovlp_score, expect, ngaps, gaplen};
}


void write_ovlpf(std::string line, HASH_SEQ &r2seq_phred, std::ofstream &outpaf, bool mode) {

    std::string r1;
    int length1;
    int start1;
    int end1;
    char strand;
    std::string r2;
    int length2;
    int start2;
    int end2;
    int n_match_bases;
    int alen;
    double ovlp_len;
    double identity;
    std::string cigar;

    std::string seq1;
    std::string seq2;
    std::string phred1;
    std::string phred2;
    std::vector<std::string> svec;

    std::vector<double> ovlp_vec;
    double ovlp_score;
    double expect;
    double ngaps;
    double gaplen;
    int overhang;
    int maplen;
    int b2;
    int e2;
    double ratio; //overhang to mapping length ratio

    std::smatch cigar_entry;
    std::regex pattern(".*cg:Z:(.*)");
    if (line.empty()) {
        return;
    } else if (std::regex_match(line, cigar_entry, pattern)) {
        cigar = cigar_entry[1];
    } else {
        std::cerr << "Error: No CIGAR entry in this line. Skip...\n";
        return;
    }

    boost::split(svec, line, boost::is_any_of(" \t"), boost::token_compress_on);
    r1 = svec[0];
    length1 = std::stoi(svec[1]);
    start1 = std::stoi(svec[2]);
    end1 = std::stoi(svec[3]);
    strand = svec[4][0];
    r2 = svec[5];
    length2 = std::stoi(svec[6]);
    start2 = std::stoi(svec[7]);
    end2 = std::stoi(svec[8]);
    n_match_bases = std::stoi(svec[9]);
    alen = std::stoi(svec[10]);
    ovlp_len = 0.5 * (end1 - start1 + end2 - start2);
//    ovlp_len = alen; // maybe it is more reasonable
    identity = 1.0 * n_match_bases / alen;
    if (strand == '-'){
        /*
         overhang region: ***
                   b1        e1    l1
        v ------------------------->
               |***|/////////|*****|
        w  <----------------------------
                   b2        e2         l2
        */

        b2=length2-end2;
        e2=length2-start2;
    } else{
        b2=start2;
        e2=end2;
    }

    overhang=std::min(start1,b2) + std::min(length1-end1,length2-e2);
    maplen=std::max(end1-start1,e2-b2);
    ratio=1.0* overhang/maplen; //from algorithm 5 in minimap paper

    if ((r2seq_phred.find(r1) == r2seq_phred.end()) || (r2seq_phred.find(r2) == r2seq_phred.end())) {
//            std::cout<<"reads: "<<r1<<"\t"<<r2<<"\n";
//            for(auto&p: r2seq_phred){
//                std::cout<<p.first<<"\n";
//            }
        std::cerr << "READS_ID: " << r1 << " OR " << r2 << " was not found in fastq file. Skip...\n";
        return;
    }


    seq1 = r2seq_phred[r1][0];
    seq2 = r2seq_phred[r2][0];
    phred1 = r2seq_phred[r1][1];
    phred2 = r2seq_phred[r2][1];

    ovlp_vec = analyze_overlap(seq1, seq2, phred1, phred2, start1, start2, end1, end2, strand, n_match_bases, cigar);
    ovlp_score = ovlp_vec[0];
    expect = ovlp_vec[1];
    ngaps = ovlp_vec[2];
    gaplen = ovlp_vec[3];

    mt.lock(); //mutex lock
    if (mode) {
        for (int i = 0; i < 12; i++) {
            outpaf << svec[i] << "\t";
        }
//        outpaf << ovlp_len << "\t" << identity << "\t" << ovlp_score << "\t" << expect << "\t";
        outpaf << ovlp_len << "\t" << identity << "\t" << ovlp_score << "\t" << ratio << "\t";
        outpaf << ngaps << "\t" << gaplen << "\n";
    } else {
        outpaf << r1 << "\t" << r2 << "\t" <<
               ovlp_len << "\t" << identity << "\t" << ovlp_score << "\t" << expect << "\n";
    }
    mt.unlock();


}